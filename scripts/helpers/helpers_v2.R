# below are a set of functions either taken from, or adapted from, the QPress R package: https://github.com/SWotherspoon/QPress
# devtools::install_github("SWotherspoon/QPress",ref="Constrain")

# this function simulates matrices and gets stable ones and handles perturbations

system.sim_press <- function (n.sims, constrainedigraph, required.groups = c(0), from, to, class, arid, prob, score,
                              sampler = community.sampler_con2(constrainedigraph, required.groups, from, to, class, perturb, spatial, arid, score),  
                              perturb, spatial) {
  
  edges1 <- constrainedigraph$edges
  labels <- node.labels(edges1)
  index <- function(name) {
    k <- match(name, labels)
    if (any(is.na(k))) 
      warning("Unknown nodes:", paste(name[is.na(k)], collapse = " "))
    k
  }
  
  stableout <- list()
  stablews_array <- array(NA, dim = c(length(labels), length(labels), n.sims))
  stable <- 0
  unstable <- 0
  
  k.perturb <- index(names(perturb))
  S.press <- double(length(labels))
  S.press[k.perturb] <- -perturb
  
  while (stable < n.sims) {
    zerosion <- sampler$selecterosion(score[1]) 
    zcdev <- sampler$selectcdev(score[2]) 
    zrain <- sampler$selectrain(score[3]) 
    zdrought <- sampler$selectdrought(score[4]) 
    zcyc <- sampler$selectcyc(score[5]) 
    zslr <- sampler$selectslr(score[6]) 
    zss <- sampler$select2(prob[1], prob[2]) # propagule uncertainty
    W <- sampler$community()
    if (!stable.community(W) & !is.null(solve(W, S.press))){
      unstable <- unstable + 1
      next
    } else{
      stable <- stable + 1
      stableout[[stable]] <- data.frame(nsim = stable, var = labels, outcome = solve(W, S.press))
      stablews_array[,,stable] <- W
    }
  }
  
  stableout <- do.call(rbind, stableout)
  stability <- data.frame(Num_unstable = unstable, Num_stable = stable, Potential_stability =  stable/(unstable+stable))
  list(edges = edges1, stability.df = stability, stableoutcome = stableout, stableweights = stablews_array)
}

# Construct bounding sets used to order weights to meet the edge weight constraints.
# These bounds sets are used to order a set of random edge weights
# so that they meet the imposed constraints.

bound.sets <- function(constrained) {
  a <- constrained$a
  b <- constrained$b
  
  ## Find all weights bounded above by the root weight r
  bounded <- function(r) {
    v <- unique(a[b %in% r])
    repeat {
      va <- setdiff(a[b %in% v],v)
      if(length(va)==0) break;
      v <- c(va,v)
    }
    v
  }
  
  bounds <- list()
  n <- 0
  
  ## Unvisited weights
  us <- b
  ## Unbounded weights
  vs <- setdiff(b,a)
  while(length(vs) > 0) {
    for(v in vs) {
      ## Find all weights bounded by v
      bs <- bounded(v)
      if(v %in% bs) warning("Cyclic constraints found")
      bounds[[n <- n+1]] <- c(v,bs)
    }
    ## Unvisited weights
    us <- setdiff(us,vs)
    ## Weights bounded only by visited weights
    vs <- setdiff(us,a[b %in% us])
  }
  bounds
}

# Order a set of absolute edge weights to meet imposed edge weights
# constraints.

constraint.order <- function(w,bounds) {
  for(bs in bounds) {
    k <- which.max(w[bs])
    if(k!=1) w[bs[c(1,k)]] <- w[bs[c(k,1)]]
  }
  w
}

# community sampler that allows weights to be constrained for certain edges
# and allows relative strengths of edges to be constrained
# based on 'community.ordering.sampler' function from Wotherspoon

community.sampler_con2 <- function (constrainedigraph, required.groups = c(0), from, to, class, perturb, spatial, arid, score) # from, to, and class arguments for constraining edges as 'High', "Med', or 'Low', just a vector
{
  edges <- constrainedigraph$edges
  if (length(from) > 0){ # here add new column to edges with high, medium or low classification
    constrain <- data.frame(From = from, To = to, Class = class)
    if(spatial == 'N'){ # in non-spatial model, only if coastal development is being perturbed do we constrain SeaLevelRise -> LandwardMang edge
      if(length(which(names(perturb) == 'CoastalDev')) != 0){ 
        edges$Class <- dplyr::left_join(edges, constrain)$Class
      }else{
        edges$Class <- dplyr::left_join(edges, constrain)$Class
        edges <- mutate(edges, Class = ifelse(To == 'LandwardMang', 'NA', Class))
      }
    }else{ # in spatial model, always constrain SeaLevelRise -> LandwardMang edge according to pop. density, i.e. coastal development
      edges$Class <- dplyr::left_join(edges, constrain)$Class
    }
  }
  n.nodes <- length(node.labels(edges))
  weight.labels <- edge.labels(edges)
  n.edges <- nrow(edges)
  W <- matrix(0, n.nodes, n.nodes)
  lower <- ifelse(edges$Type == "U" | edges$Type == "N", -1L, 
                  0L)
  upper <- ifelse(edges$Type == "U" | edges$Type == "P" , 1L, 
                  0L)
  ## set up constraints for high, medium, low
  lower[which(edges$Class == 'H' & edges$Type == 'P')] <- 0.66667
  upper[which(edges$Class == 'H' & edges$Type == 'N')] <- -0.66667
  lower[which(edges$Class == 'M' & edges$Type == 'P')] <- 0.33334
  upper[which(edges$Class == 'M' & edges$Type == 'P')] <- 0.66666
  lower[which(edges$Class == 'M' & edges$Type == 'N')] <- -0.66666
  upper[which(edges$Class == 'M' & edges$Type == 'N')] <- -0.33334
  upper[which(edges$Class == 'L' & edges$Type == 'P')] <- 0.33333
  lower[which(edges$Class == 'L' & edges$Type == 'N')] <- -0.33333
  k.edges <- as.vector(unclass(edges$To) + (unclass(edges$From) - 
                                              1) * n.nodes)
  uncertain <- which(!(edges$Group %in% required.groups))
  expand <- match(edges$Pair[uncertain], unique(edges$Pair[uncertain]))
  n.omit <- 1 # forcing this to be one
  bounds <- bound.sets(constrainedigraph)
  zerosion <- c(1,1)
  zcdev <- c(1,1)
  zrain <- 1
  zdrought <- 1
  zcyc <- c(1,1,1,1)
  zslr <- c(1,1)
  
  community <- if (n.omit > 0) {
    function() {
      r <- runif(n.edges, lower, upper)
      r <- sign(r) * constraint.order(abs(r), bounds)
      r[c(3,4)] <- r[c(3,4)] * zss # here making land/sea propagule to land/sea mang link uncertain
      r[c(5,6)] <- r[c(5,6)] * zerosion
      r[c(9,10)] <- r[c(9,10)] * zcdev
      r[7] <- r[7] * zrain
      r[19] <- r[19] * zdrought
      r[c(15,16,17,18)] <- r[c(15,16,17,18)] * zcyc
      r[c(13,14)] <- r[c(13,14)] * zslr
      W[k.edges] <- r
      W
    }
  }
  else {
    function() {
      r <- runif(n.edges, lower, upper)
      r <- sign(r) * constraint.order(abs(r), bounds)
      W[k.edges] <- r
      W
    }
  }
  
  selecterosion <- if (n.omit > 0) {
    function(perosion) {
      zerosion <<- rep(rbinom(1, 1, perosion), length(zerosion))
    }
  }
  else {
    function(perosion = 0) {
      zerosion
    }
  }
  
  selectcdev <- if (n.omit > 0) {
    function(pcdev) {
      zcdev <<- rep(rbinom(1, 1, pcdev), length(zcdev))
    }
  }
  else {
    function(pcdev = 0) {
      zcdev
    }
  }
  
  selectrain <- if (n.omit > 0) {
    function(prain) {
      zrain <<- rep(rbinom(1, 1, prain), length(zrain))
    }
  }
  else {
    function(prain = 0) {
      zrain
    }
  }
  
  selectdrought <- if (n.omit > 0) {
    function(pdrought) {
      zdrought <<- rep(rbinom(1, 1, pdrought), length(zdrought))
    }
  }
  else {
    function(pdrought = 0) {
      zdrought
    }
  }
  
  selectcyc <- if (n.omit > 0) {
    function(pcyc) {
      zcyc <<- rep(rbinom(1, 1, pcyc), length(zcyc))
    }
  }
  else {
    function(pcyc = 0) {
      zcyc
    }
  }
  
  selectslr <- if (n.omit > 0) {
    function(pslr) {
      zslr <<- rep(rbinom(1, 1, pslr), length(zslr))
    }
  }
  else {
    function(pslr = 0) {
      zslr
    }
  }
  
  select2 <- if (arid == 'Y') {
    function(p2,p3) {
      zss <<- c(rbinom(1, 1, p2), rbinom(1, 1, p3)) # if arid, use the probability of establishment for landward mangroves in arid environment, and higher for seaward mangroves
    }
  }  
  else {
    function(p2, p3) {
      zss <<- c(rbinom(1, 1, p3), rbinom(1, 1, p3)) # if not arid, set probability of establishment to same for both landward and seaward mangroves
    }
  }
  weights <- function(W) {
    W[k.edges]
  }
  list(community = community, selecterosion = selecterosion,selectcdev = selectcdev,selectrain = selectrain, selectdrought = selectdrought, selectcyc = selectcyc, selectslr = selectslr, select2 = select2, weights = weights, 
       weight.labels = weight.labels, uncertain.labels = weight.labels[uncertain])
}

